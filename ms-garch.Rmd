---
title: "基于MS-GARCH模型的上海银行同业拆借利率波动性分析"
author: "Jin"
date: "2019-01-14"
output:
  html_document:
    highlight: haddock
    theme: null
    number_sections: yes
    md_extensions: +east_asian_line_breaks
    keep_md: true
    toc: false
    pandoc_args: ["--filter", "pandoc-crossref", "-M", "eqnPrefix="]
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
    md_extensions: +east_asian_line_breaks
    pandoc_args: ["--listing", "--filter", "pandoc-crossref"]
  word_document:
    reference_docx: word-styles-01.docx
    md_extensions: +east_asian_line_breaks
    pandoc_args: ["--filter", "pandoc-crossref"]

css: markdown.css
autoEqnLabels: true
eqnPrefixTemplate: ($$i$$)
linkReferences: true
bibliography: msgarch.bib
csl: chinese-gb7714-2005-numeric.csl
link-citations: true
---

# 简介
[//]: # 问题界定，文献综述，文章结构简述

同业拆放，是指金融机构在货币市场上通过融通的方式来调整资金的过剩与不足，利用资金
融通过程的时间差、空间差进行短期借贷。如银行同业拆借在解决银行短期内资金短缺中起
着重要的调节作用。同业拆放利率即金融机构之间的短期资金借贷利率，是货币市场的核心
利率之一。同业拆放利率作为重要的经济杠杆，在国家经济发展中占据着重要位置。我国于
 $1996$ 年 $6$ 月成立了第一个银行间同业拆放市场，开启了放宽利率管制之路。同年，央行推出
的我国银行间同业拆放利率 (CHIBOR, china interbank offered rate) 标志着我国利率市
场化的序幕正式拉开。 $2006$ 年 $10$ 月，上海银行间同业拆放利率 (SHIBOR, shanghai
interbank offered rate) 市场建立，代表我国在利率市场化的道路上又迈出了关键的一步。

利率风险是指市场利率变动的不确定性给商业银行造成损失的可能性。随着我国利率市场化
的展开，利率受到更多市场力量的影响，最终导致利率水平波动的日益加剧与难以预测，行
业风险随之增大。由于我国长期实行利率管制政策，因此以商业银行为代表的金融机构长时
间缺乏对利率风险管理的经验。在现存的经济环境下，如何准确地度量、有效地控制同业拆
放利率风险，应对利率市场化的挑战，是商业银行亟待解决的难题之一。

上世纪 $70$ 年代以来，国外利率市场化浪潮不断扩大，西方学者随之开始了对利率风险的研究。
Black、Scholes等( $1973$ ) 认为短期利率具有对数正态分布的特性，并提出Black-Scholes期
权定价模型[@Black1973]。Bollerslev( $1986$ )运用GARCH模型对短期利率波动进行估计得到了
较好的效果，此模型能够有效克服金融时间序列数据的高峰厚尾与波动集群的特性
[@Bollerslev1986]。Nelson( $1991$ )、Zakoian( $1994$ )相继在前人基础上，研究出GARCH族扩
展模型，如TGARCH、EGARCH，这也是目前研究利率波动性问题的主流模型
[@Nelson1991;@Zakoian1994]。Mittnik、Paolella( $2000$ )推广了GARCH模型的残差分布，
使用t分布和GED分布应用于VaR的计算中，最终结果显示推广分布下有更好的拟合与预测效
果[@Mittnik2000]。Dias、Embrechts( $2004$ )提出GARCH-copula模型，在GARCH模型的基础上，
再使用copula函数研究多个金融时间序列之间的相关结构。Xu, and Wirjanto ( $2010$ )研
究了基于正态混合分布的GARCH模型的理论结果[@Xu2010]。Braione and Scholtes ( $2014$ )
使用了基于正态分布, t分布, 和指数分布的GARCH模型来计算并比较金融时间序列的VaR值
[@Braione2014]。

由于我国利率市场起步相对较晚，目前国内学者对VaR模型的应用主要集中于市场波动较明
显的股票市场和债券市场，而对于商业银行利率风险的研究较少。同时，大部分研究仅停留
在传统的VaR模型，它对于描述金融时间序列的尖峰厚尾性存在一定的缺陷，无法得到精确
的风险值。穆海权、余雪红和田怀姝( $1999$ )首次使用利率敏感性缺口模型对商业银行利率进
行研究[@穆海权1999]。张玉桂、苏云鹏等( $2009$ )基于无损卡尔曼滤波估计方法，分别使用
Vasicek和CIR模型刻画SHIBOR的波动性，研究其期限结构[@张玉桂2009]。李良松( $2009$ )的
研究表明广义误差分布的蒙特卡罗模拟方法适用于描述上海银行间同业拆放利率"左尾"的
VaR;广义误差分布结合利率期限结构模型的方法适用于描述上海银行间同业拆放利率"右尾"
的VaR[@李良松2009]。吴冠、杨琪( $2011$ )研究表明GARCH模型对拟合拆借利率的波动特征有
较好的效果[@吴冠2011]。房小定、吕鹏( $2013$ )利用E-GARCH-GED模型对上海银行间同业拆放
利率市场对数收益率在险值进行计算[@房小定2013]。项卫星,李宏瑾( $2014$ )指出SHIBOR具备
市场代表性、基准性和稳定性，符合货币市场基准利率的基本特征[@项卫星2014]。曾裕峰
等( $2015$ )构建了基于CAViaR模型的Shibor风险测度VaR模型，研究结果发现,CAViaR模型的风
险预测效果优于传统的GARCH族模型[@曾裕峰2015]。严佳佳，郭春松等( $2015$ )基于
AR-GARCH-POT方法度量不同期限香港离岸人民币同业拆借利率的风险值[@严佳佳2015]。吴
俊，杨继旺( $2015$ )通过构建ARMA-GARCH族模型对SHIBOR进行实证研究，结果发现，GED分布
较T分布更好拟合利差波动序列的"尖峰厚尾"特征[@吴俊2015]。冷琦琪，王学军( $2018$ )通过
构建不同分布下的EGARCH模型，对上海银行间同业拆放利率市场对数收益率在险值进行计算
[@冷琦琪2018]。

虽然已有众学者对银行同业拆借利率进行性质以及风险度量等方面的研究，但国内对计算同
业拆借利率在险价值的研究方法尚不成熟，主要的方法还是基于GARCH族模型，并将收益率
的分布假定为单一分布，进而计算VaR值，这种方法虽能描述银行间同业拆借利率的波动特
征，但精度有待提高。即使相关学者已经应用虚拟变量的方法对利率波动进行刻画，但其并
不能对波动变化的实际过程进行实时反映，具有一定的滞后性和局限性。为此，本文将使用
Markov-Switching-GARCH模型对SHIBOR的变化进行深入探究，以更好地拟合同业拆借利率市
场的真实情况，使得VaR值估计结果更加精确。

本文第二部分对所使用的统计理论和模型进行简单介绍，第三部分进行实证分析，具体选用
上海银行间同业拆借利率数据对同业拆借利率市场的在险价值VaR进行度量。考虑到SHIBOR数
据具有尖峰厚尾特征，引入混合数分别为k= $2$ 、 $3$ 、 $4$ 的混合分布来代替普通正态分布和厚尾
分布。通过选择不同种类组合的混合分布GARCH族模型来对利率样本序列的均值方程和方差
方程进行拟合，计算出同业拆借利率的在险价值，并从准确性和合适性两方面与普通正态分
布和某一厚尾分布下的VaR值进行对比，从而找出最优的条件异方差模型。确定最优模型后，
根据模型特性分析上海银行间同业拆借利率的波动性特征，得出最终结论。

# 马尔科夫区制转换 GARCH 模型

普通GARCH模型只能刻画数据在一种状态时的方差的性质，但对于金融数据而言，外部冲击
往往会使数据的波动状况发生结构性突变。比如央行近年频繁采取“降准”的货币政策，这会
使银行间短期资金供给增加，同业拆借利率降低，波动性也逐渐平缓。此时如果继续采用普通
GARCH模型，会使模型与真实情况相差较大，高估同业拆借市场的风险，不利于对我国利率
市场的管控。而使用马尔科夫链与GARCH模型的混合模型则可以刻画同业拆借利率方差的动
态变化，即在序列高波动和低波动时期分别拟合不同的GARCH模型。同时，由于经济事件往
往具有周期性，过去某一时期的波动性状况在未来也可能会复现，针对该种情况，就需要
状态转换的MS-GARCH模型来进行描述。

## 马尔科夫转换模型介绍

马尔科夫转换模型能够将金融时间序列划分为若干个区间，分别研究不同区间下的数据特
征，可以更准确地描述金融市场真实情况。一般化的马尔科夫转换模型可以表示如下：

$${Y_t} = \beta_0^{(s_t)}+\sum\limits_{i = 1}^{{n_1}} {\beta _i^{(s_t)}{X_i}}  + 
\sum\limits_{i = 1}^{{n_2}} {\beta _i^{(s_t)}{Y_{t - j}}}  + {\varepsilon ^{(s_t)}},\quad 
\varepsilon ^{(s_t)} \sim N\left(0,\sigma ^{2(s_t)} \right)
$$ {#eq:ms-model1}

[@eq:ms-model1] 式中 ${y_t:t=1,2,…,T}$ 表示金融时间序列， $k$ 表示区制的个数，$n_1$ , $n_2$
分别表示外生变量和自回归的阶数。设共有 $k$ 个区制， $s_t$ 表示 $y_t$ 所处的
区制的状态。不同区制的转移遵循具有以下转移矩阵的马尔科夫随机过程：

$${P_{ij}} = \Pr \left( {{(s_{t + 1})} = i\left| {{(s_t)} = j} \right.} \right)
且\sum\limits_{i = 1}^k {{P_{ij}}}  = 1$$ {#eq:ms-model2}

[@eq:ms-model2] 式中 ${P_{i,j}}$ 表示从状态 $j$ 转移到状态 $i$ 的概率。

## GARCH模型介绍

金融时间序列往往具有显著的波动性聚集特征，如果继续使用传统的线性计量模型会
使结果失真，为此Bollerslev在Engle的相关研究上提出了GARCH模型以解决类似问题，
该模型结构如下：

$$\left\{ {\begin{array}{l}
{{y_t} = f\left( {t,{y_{t - 1}},{y_{t - 2}}, \cdots } \right) + {\varepsilon _t}}\\
{{\varepsilon _t} = \sqrt {{h_t}} {e_t}}\\
{{h_t} = \omega  + \sum\limits_{i = 1}^p {{\alpha _i}{h_{t - i}}}  + 
\sum\limits_{j = 1}^q {{\beta _j}{\varepsilon ^2_{t - j}}} }
\end{array}} \right.$$ {#eq:ms-model3}

[@eq:ms-model3] 式中， ${y_t}$ 表示时刻 $t$ 的收益率, $h_t$ 表示条件方差， ${e_t}$
是均值为 $0$ ，方差相等的独立同分布随机变量序列。第一个方程为均值方程，用来描述收益
率序列条件均值的变化过程，第三个方程为方差方程，用来描述收益率序列条件方差
的变化过程。

## MS-GARCH模型介绍

设 ${y_t:t=1,2,…,T}$ 表示金融时间序列，共有 $k$ 个区制, $y_t$ 所处的区制
用 $s_t$ 表示，即 ${(s_t)} \in \left( {1,2, \cdots ,k} \right)$ 。若 $y_t$ 满足

$${y_t} = {\mu ^{(s_t)}} + {\varepsilon_t ^{(s_t)}}$$ {#eq:ms-model4}

[@eq:ms-model4] 式中 $\mu ^{(s_t)}$ 表示 $y_t$ 在状态 $s_t$ 下的均值方程

$${\mu ^{\left( {{s_t}} \right)}} = {f^{\left( {{s_t}} \right)}}\left( {t,{y_{t - 1}},{y_{t - 2}}, \cdots } \right)$${#eq:ms-model5}

$\varepsilon _t^{{(s_t)}}$ 表示 $y_t$ 在状态 $s_t$ 下的条件方差方程，服从
如下 $GARCH(p,q)$ 模型：

$$\left\{ {\begin{array}{l}
{{\varepsilon _t^{{(s_t)}}} = \sqrt {{h_t^{{(s_t)}}}} {e_t}} \\
{{h_t^{{(s_t)}}} = {\omega ^{(s_t)}} + \sum\limits_{i = 1}^p {{\alpha _i^{{(s_t)}}}{h_{t-i}^{(s_t)}}}  + 
\sum\limits_{j = 1}^q {{\beta _j^{{(s_t)}}}{\varepsilon _{t-j}^{2(s_t)}}} }
\end{array}} \right.$${#eq:ms-model6}

[@eq:ms-model6]式中 ${e_t}$ 是均值为 $0$ ，方差相等的独立同分布随机变量序列。
$\omega^{(s_t)}$ , $\alpha ^{(s_t)}$ , $\beta ^{(s_t)}$ 分别表示在当前区制下的各参数
的值。不同区制的转移由一个 $k$ 状态的的马尔科夫随机过程控制，状态转移矩阵如下：

$$P = \left[{\begin{array}{cccc}
{{p_{11}}}&{{p_{12}}}& \cdots &{{p_{1k}}}\\
{{p_{21}}}&{{p_{22}}}& \cdots &{p_{2k}}\\
 \vdots & \vdots & \ddots & \vdots \\
{{p_{k1}}}&{{p_{k2}}}& \cdots &{{p_{kk}}}
\end{array}} \right]$${#eq:ms-model7}

[@eq:ms-model7]式中 ${p_{i,j}}$ 表示从状态 $j$ 转移到状态 $i$ 的概率。

混合正态分布是由两个或两个以上正态分布的加权组合形成的分布，且任意两个正态分布
之间均是独立的，因此混合正态分布也可以理解为马尔科夫转换模型的一个特例。由于不
同的正态分布有着不同的均值和方差,所以混合正态分布通常比正态分布能够更好地刻画
尖峰性和厚尾性，因此本文亦将使用混合分布GARCH模型对shibor收益率数据进行拟合。
模型估计部分采用R软件中的MSGARCH包实现。

# 实证分析

## 数据来源及数据处理

银行间同业拆借利率是我国最早市场化的利率，在我国的利率体系中扮演着重要的角色。
其中上海银行间同业拆借利率(Shanghai Interbank Offered Rate,SHIBOR)自 $2006$ 年 $10$ 月
成立以来尤受重视。目前公布的品种依据时间划分主要包括隔夜（O/N）、 $1$ 周（ $1W$ ）、
 $2$ 周（ $2W$ ）、 $1$ 个月（ $1M$ ）等品种。

本文所收集的样本区间是 $2006$ 年 $10$ 月 $8$ 日至 $2018$ 年 $12$ 月 $29$ 日，总
计 $3060$ 个SHIBOR隔夜拆借率数据。数据全部来自于上海银行间同业拆借利率官
网(http://www.shibor.org/)。假设 ${R_t}$ 为第 $t$ 期的隔夜拆借利率，在探讨金融时间
序列变化时，为了消除数据的非平稳性，常常使用对数收益率：

$${r_t} = \ln {R_t} - \ln {R_{t - 1}}$${#eq:ms-model8}

其中， ${R_{t - 1}}$ 为上一期的隔夜拆借利率，通过计算，可以得到 $3059$ 个上海银行隔夜
同业拆借的收益率的时间序列。SHIBOR隔夜拆借利率和对数收益率时序图如下：

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = getwd())
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval=T, include=FALSE}
## 准备
rm(list=ls())
options(digits=5)
options(scipen=5)
graphics.off()
## path <- "F:/github_repo/shibor-msgarch/" 
## setwd(path)
#Sys.setlocale('LC_ALL','C') 
Sys.setlocale("LC_ALL", "Chinese")


## 加载包
library(zoo)
library(forecast)
library(tseries)
library(xts)
library(ggplot2)
library(FinTS)
library(moments)
library(devtools)
library(FinTS)
library(MSGARCH)
library(fBasics)
library(knitr)

## 载入数据
#上海银行同业拆借率
data=read.csv("Shibor_data.csv",header=T)
shibor<-data[,2]
shibor.date<-as.Date(data[,1])

#计算收益率
#shibor.rt<-diff(log(shibor))
shibor.rt<- vector()
for (i in 1 : 3059) {shibor.rt[i] <- (log(shibor[i+1])-log(shibor[i]))}
#收益率转为时间序列LOGRt-LOGR(t-1) 
```

```{r,eval=T,echo=FALSE,fig.cap = "图1 SHIBOR隔夜拆放利率和对数收益率时序图"}
par(mfrow=c(2,1))
par(mar=c(2,4,1,2))
plot(shibor.date,shibor,type="l",xlab="日期",ylab="隔夜拆借利率")
plot(shibor.date[-1],shibor.rt,type="l",xlab="日期",ylab="对数收益率",cex.main=0.95,las=1)
#显然具有波动应聚集的特征
```

由图 $1$ 可以看出，SHIBOR隔夜拆借利率在 $2006$ - $2010$ 年波动幅度较平稳，在 $2010$ - $2016$ 年
波动幅度较大，在 $2016$ - $2018$ 年波动趋于平稳。对数收益率序列的方差随时间变化而变化，
而且有时变化得十分剧烈。同时，对数收益率的波动存在显著的波动集群效应，大波动后面跟随
着大波动，小波动后跟随着小波动，且大波动率和小波动率的时期交替出现。

## 数据探索性分析

### 正态性检验

建立模型之前对基础数据进行正态性检验是十分必要的。首先可以通过计算对数收益率
数据的描述统计量、直方图和QQ图进行描述性分析。

```{r,eval=T,include=FALSE}
shibor.rt1<-basicStats(shibor.rt)
shibor.rt1
shibor.rt2<- as.data.frame(t(shibor.rt1[c(7,14,16,15),]))
colnames(shibor.rt2) <- c("均值","标准差","偏态系数","峰态系数")
```

```{r,eval=T,echo=F,message=FALSE,warning=FALSE,comment=""}
kable(shibor.rt2,row.names =F,align = "c",caption="样本描述性分析结果")
```

对数收益率的偏度为`r shibor.rt2[1,3] `，峰度为`r shibor.rt2[1,4] `，而正态分布的偏
度和峰度均为 $0$ ，故对数收益率序列具有右偏性和尖峰性，初步判断不服从正态分布。

```{r,eval=T,echo=F,fig.align="center",fig.cap="图2 SHIBOR收益率频率分布直方图和正态Q-Q图"}
par(mfrow=c(1,2))
#绘制直方图
hist(shibor.rt,main=NULL,breaks = 50)

#正态性检验
qqnorm(shibor.rt,main =NULL)
qqline(shibor.rt)                #QQ图检验非正态
```

图 $2$ 的直方图和QQ图也显示对数收益率序列不服从正态分布。直方图中，对数收益率序列的尾
部明显长于普通正态分布，具有金融序列的尖峰厚尾特征。QQ图可以直观的验证一组数据是否
服从正态分布，图中对数收益率的散点明显偏离代表正态分布的直线，且在左侧表现出散点图
分布下摆的趋势，右侧表现出分布上扬的趋势，说明该序列具有明显的尖峰厚尾特征。

```{r,eval=T,include=F}
#正态性检验
jarque.bera.test(shibor.rt)    #JB检验非正态
```

以上均是描述性分析得出的初步判断，为了更加科学地判断收益率序列的特征，采用
J-B（Jarque-Bera）统计量对收益率数据进行正态性检验，统计量J-B对应的p值为 $2e-16$ ,
小于显著性水平 $0.05$ ，故拒绝原假设，验证了之前收益率数据不服从正态分布的判断。

### 平稳性检验

```{r, eval=T, include=FALSE}
#平稳性检验
pp.test(shibor.rt)  #平稳
```

在对时间序列进行分析时，必须要进行平稳性检验。通过使用适用于异方差场合的PP检验法
(Phillips-Person Test)对SHIBOR对数收益率序列进行检验发现，相关统计量对应的P值
为 $0.01$ ，小于 $0.05$ ，表明该序列是平稳的。

### 自相关性检验

```{r, eval=T, echo=F,fig.align="center",fig.cap="图3 SHIBOR收益率自相关图和偏自相关图"}
#自相关性检验
par(mfrow=c(1,2)) 
acf(shibor.rt,main="",xlab="滞后期",ylab="ACF")#画自相关图
title(main = "(a)the ACF of Return",cex.main=0.95)
pacf(shibor.rt,main="",xlab="滞后期",ylab="PACF",las=1)#画偏自相关图
title(main="(b)the PACF of Return",cex.main=0.95)
```

```{r,eval=T,include=F}
acf(shibor.rt,plot = F,lag.max = 15)
pacf(shibor.rt,plot = F,lag.max = 15)
Box.test(shibor.rt,lag=10,type = "Ljung")
library(forecast)
library(stats)
fit1=Arima(shibor.rt,order = c(1,0,1))
fit1.res=c("fit1",AIC(fit1),BIC(fit1))
fit2=arima(shibor.rt,order = c(1,0,2))
fit2.res=c("fit2",AIC(fit2),BIC(fit2))
fit3=arima(shibor.rt,order = c(2,0,1))
fit3.res=c("fit3",AIC(fit3),BIC(fit3))
fit4=arima(shibor.rt,order = c(2,0,2))
fit4.res=c("fit4",AIC(fit4),BIC(fit4))
res1=data.frame(fit1.res,fit2.res,fit3.res,fit4.res)#arma(1,2)最优
res1
auto.arima(shibor.rt)
resi<-residuals(fit2,standardize=T)#获得标准化残差
res.ts<-ts(resi,frequency = 250)
```

```{r,eval=T,include=F}
Box.test(resi,lag=10,type = "Ljung")
```



对上海银行间隔夜拆放利率进行自相关检验，这里分别运用自相关系数、偏自相关系数和Ljung-Box 
Q统计量对SHIBOR对数收益率序列进行自相关分析。

Ljung-Box Q统计量的值为 $107.12$ ，对应p值为 $6.7e-16$ ,远小于显著性水平 $0.05$ ，
故收益率序列为非白噪声序列，具有较强的自相关性，需要进一步提取观察值序列的相关信息。
综合之前的平稳性检验，可以判断对数收益率序列是一个蕴涵相关信息的平稳序列，故建
立ARMA(p,q)线性模型来拟合该序列的变化过程。

```{r, eval=T, echo=F,fig.align="center",fig.cap="图4 SHIBOR收益率残差序列图"}
plot(res.ts,type="l")
```
图 $3$ 中的自相关系数和偏自相关系数均显示出拖尾的性质，考虑到模型的简洁性，本文将ARMA模型参数p,q
的取值设置为 $1$ ， $2$ ，尝试使用ARMA( $1$ , $1$ )、ARMA( $1$ , $2$ )、
ARMA( $2$ , $1$ )、ARMA( $2$ , $2$ )对序列进行拟合。最终根据参数显著性检验以
及AIC和BIC准则选择最优模型为ARMA( $2$ , $1$ )，其AIC和BIC值最小，
分别为 $-6734.29$ 和 $-6704.16$ 。根据已经得出的参数估计值，
可以获得ARMA( $2$ , $1$ )模型的残差序列，如图 $4$ 所示。对其进行白噪声检验，
Ljung-Box Q统计量显示残差序列无自相关性，p值为 $0.0074$ ，小于 $0.05$ 的显著性水平。

### ARCH效应检验

```{r, eval=T, include=F}
#ARCH效应检验
ArchTest(resi,lag=12)  #存在ARCH效应
```

观察图 $4$ 中的残差序列可以发现，虽然其波动是平稳的，但在 $2006$ - $2008$ ， 
$2010$ - $2013$ ， $2018$ 这些时间段波动持续偏大，在其余时间段波动持续偏小，呈现出聚集
效应，故接下来进行ARCH效应检验。两种常用的ARCH检验统计方法是Portmanteau Q检验和LM检验。
这里使用Portmanteau Q检验对收益率数据进行分析。根据R软件分析结果可知P值小 $2e-16$ ,
远小于 $0.05$  ，故拒绝原数据，即认为残差平方序列自相关，残差序列存在ARCH效应。

```{r, eval=F, echo=F}
#拟合GARCH
library(timeDate)
library(timeSeries)
library(fBasics)
library(fGarch)
#残差平方的自相关性分析
par(mfrow=c(2,1))
rt.square<-resi^2
acf(rt.square,main="",xlab="lag(c)",ylab="ACF",las=1)#画自相关图
title(main = "(c)the ACF of resi Square",cex.main=0.95)
pacf(rt.square,main="",xlab="Lag(d)",ylab="PACF",las=1)#画偏自相关图
title(main = "(d)the PACF of resi Square",cex.main=0.95)
Box.test(rt.square,lag = 10,type = "Ljung")
```

```{r, eval=F, echo=F}
#假定条件分布为正态分布
##拟合GARCH(1,1)模型
m1<-garchFit(~arma(1,2)+garch(1,1),data =shibor.rt ,trace = F)
summary(m1)
m1.res=c("m1",m1@fit$ics[-c(3,4)])
##拟合GARCH(2,1)模型
m2<-garchFit(~arma(1,2)+garch(2,1),data =shibor.rt,trace = F)
summary(m2)#系数不显著，舍去
m2.res=c("m2",m2@fit$ics[-c(3,4)])
##拟合GARCH(1,2)模型
m3<-garchFit(~arma(1,2)+garch(1,2),data =shibor.rt,trace = F)
summary(m3)
m3.res=c("m3",m3@fit$ics[-c(3,4)])
##拟合GARCH(2,2)模型
m4<-garchFit(~arma(1,2)+garch(2,2),data =shibor.rt,trace = F)
summary(m4)#所估参数出现空值，舍去
m4.res=c("m4",m4@fit$ics[-c(3,4)])
#假定条件分布为t分布
##拟合GARCH(1,1)模型
m5<-garchFit(formula = ~arma(1,2)+garch(1,1),data =shibor.rt,trace = F,cond.dist = "std")
summary(m5)
m5.res=c("m5",m5@fit$ics[-c(3,4)])
##拟合GARCH(2,1)模型
m6<-garchFit(formula = ~arma(1,2)+garch(2,1),data =shibor.rt,trace = F,cond.dist = "std")
summary(m6)#所估参数出现空值，舍去
m6.res=c("m6",m6@fit$ics[-c(3,4)])
##拟合GARCH(1,2)模型
m7<-garchFit(formula = ~arma(1,2)+garch(1,2),data =shibor.rt,trace = F,cond.dist = "std")
summary(m7)
m7.res=c("m7",m7@fit$ics[-c(3,4)])
##拟合GARCH(2,2)模型
m8<-garchFit(formula = ~arma(1,2)+garch(2,2),data =shibor.rt,trace = F,cond.dist = "std")
summary(m8)#所估参数出现空值，舍去
m8.res=c("m8",m8@fit$ics[-c(3,4)])
res2=data.frame(m1.res,m2.res,m3.res,m4.res,m5.res,m6.res,m7.res,m8.res)#arma(2,1)最优
res2#m5最优
```

接下来通过对ARMA( $1$ , $2$ )模型的残差序列进行自相关性分析发现，自相关系数和偏自相
关系数均存在一定程度的拖尾性，故设置ARCH效应和GARCH效应的阶数为 $1$ ， $2$ ，分别构建
基于正态分布和t分布的ARMA( $1$ , $2$ )-GARCH( $1$ , $1$ )、ARMA( $1$ , $2$ )
-GARCH( $2$ , $1$ )、ARMA( $1$ , $2$ )-GARCH( $1$ , $2$ )、ARMA( $1$ , $2$ )-
GARCH( $2$ , $2$ )。结果显示基于t分布的ARMA-GARCH模型显著优于基于正态分布的模型，最终
根据参数显著性和AIC、BIC准则确定最优模型为ARMA( $1$ , $2$ )-GARCH( $1$ , $1$ )-t.

```{r, eval=F, echo=T}
#拟合混合分布GARCH
##两阶段混合
###混合形式为sGARCH、sGARCH
####混合分布的构成为norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm")))
m9=FitML(spec,shibor.rt)
summary(m9)
m9.res=c("m9",m9$loglik,summary(m9)$AIC,summary(m9)$BIC)

####混合分布的构成为norm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "snorm")))
m10=FitML(spec,shibor.rt)
summary(m10)
m10.res=c("m10",m10$loglik,summary(m10)$AIC,summary(m10)$BIC)

####混合分布的构成为norm、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "std")))
m11=FitML(spec,shibor.rt)
summary(m11)
m11.res=c("m11",m11$loglik,summary(m11)$AIC,summary(m11)$BIC)

####混合分布的构成为norm、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "sstd")))
m12=FitML(spec,shibor.rt)
summary(m12)
m12.res=c("m12",m12$loglik,summary(m12)$AIC,summary(m12)$BIC)

####混合分布的构成为norm、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "ged")))
m13=FitML(spec,shibor.rt)
summary(m13)
m13.res=c("m13",m13$loglik,summary(m13)$AIC,summary(m13)$BIC)

####混合分布的构成为norm、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "sged")))
m14=FitML(spec,shibor.rt)
summary(m14)
m14.res=c("m14",m14$loglik,summary(m14)$AIC,summary(m14)$BIC)

####混合分布的构成为snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm")))
m15=FitML(spec,shibor.rt)
summary(m15)
m15.res=c("m15",m15$loglik,summary(m15)$AIC,summary(m15)$BIC)

####混合分布的构成为snorm、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "std")))
m16=FitML(spec,shibor.rt)
summary(m16)
m16.res=c("m16",m16$loglik,summary(m16)$AIC,summary(m16)$BIC)

####混合分布的构成为snorm、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "sstd")))
m17=FitML(spec,shibor.rt)
summary(m17)
m17.res=c("m17",m17$loglik,summary(m17)$AIC,summary(m17)$BIC)

####混合分布的构成为snorm、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "ged")))
m18=FitML(spec,shibor.rt)
summary(m18)
m18.res=c("m18",m18$loglik,summary(m18)$AIC,summary(m18)$BIC)

####混合分布的构成为snorm、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "sged")))
m19=FitML(spec,shibor.rt)
summary(m19)
m19.res=c("m19",m19$loglik,summary(m19)$AIC,summary(m19)$BIC)

####混合分布的构成为std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std")))
m20=FitML(spec,shibor.rt)
summary(m20)
m20.res=c("m20",m20$loglik,summary(m20)$AIC,summary(m20)$BIC)

####混合分布的构成为std、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "sstd")))
m21=FitML(spec,shibor.rt)
summary(m21)
m21.res=c("m21",m21$loglik,summary(m21)$AIC,summary(m21)$BIC)

####混合分布的构成为std、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "ged")))
m22=FitML(spec,shibor.rt)
summary(m22)
m22.res=c("m22",m22$loglik,summary(m22)$AIC,summary(m22)$BIC)

####混合分布的构成为std、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "sged")))
m23=FitML(spec,shibor.rt)
summary(m23)
m23.res=c("m23",m23$loglik,summary(m23)$AIC,summary(m23)$BIC)

####混合分布的构成为sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd")))
m24=FitML(spec,shibor.rt)
summary(m24)
m24.res=c("m24",m24$loglik,summary(m24)$AIC,summary(m24)$BIC)

####混合分布的构成为sstd、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "ged")))
m25=FitML(spec,shibor.rt)
summary(m25)
m25.res=c("m25",m25$loglik,summary(m25)$AIC,summary(m25)$BIC)

####混合分布的构成为sstd、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sged")))
m26=FitML(spec,shibor.rt)
summary(m26)
m26.res=c("m26",m26$loglik,summary(m26)$AIC,summary(m26)$BIC)

####混合分布的构成为ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged")))
m27=FitML(spec,shibor.rt)
summary(m27)
m27.res=c("m27",m27$loglik,summary(m27)$AIC,summary(m27)$BIC)

####混合分布的构成为ged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "sged")))
m28=FitML(spec,shibor.rt)
summary(m28)
m28.res=c("m28",m28$loglik,summary(m28)$AIC,summary(m28)$BIC)

####混合分布的构成为sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged")))
m29=FitML(spec,shibor.rt)
summary(m29)
m29.res=c("m29",m29$loglik,summary(m29)$AIC,summary(m29)$BIC)

##三阶段混合
###混合形式为sGARCH、sGARCH、sGARCH
####混合分布的构成为norm、norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm","norm")))
m30=FitML(spec,shibor.rt)
summary(m30)
m30.res=c("m30",m30$loglik,summary(m30)$AIC,summary(m30)$BIC)

####混合分布的构成为snorm、snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm","snorm")))
m31=FitML(spec,shibor.rt)
summary(m31)
m31.res=c("m31",m31$loglik,summary(m31)$AIC,summary(m31)$BIC)

####混合分布的构成为std、std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std","std")))
m32=FitML(spec,shibor.rt)
summary(m32)
m32.res=c("m32",m32$loglik,summary(m32)$AIC,summary(m32)$BIC)

####混合分布的构成为sstd、sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd","sstd")))
m33=FitML(spec,shibor.rt)
summary(m33)
m33.res=c("m33",m33$loglik,summary(m33)$AIC,summary(m33)$BIC)

####混合分布的构成为ged、ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged","ged")))
m34=FitML(spec,shibor.rt)
summary(m34)
m34.res=c("m34",m34$loglik,summary(m34)$AIC,summary(m34)$BIC)

####混合分布的构成为sged、sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged","sged")))
m35=FitML(spec,shibor.rt)
summary(m35)
m35.res=c("m35",m35$loglik,summary(m35)$AIC,summary(m35)$BIC)

##四阶段混合
###混合形式为sGARCH、sGARCH、sGARCH、sGARCH
####混合分布的构成为norm、norm、norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm","norm","norm")))
m36=FitML(spec,shibor.rt)
summary(m36)
m36.res=c("m36",m36$loglik,summary(m36)$AIC,summary(m36)$BIC)

####混合分布的构成为snorm、snorm、snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm","snorm","snorm")))
m37=FitML(spec,shibor.rt)
summary(m37)
m37.res=c("m37",m37$loglik,summary(m37)$AIC,summary(m37)$BIC)

####混合分布的构成为std、std、std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std","std","std")))
m38=FitML(spec,shibor.rt)
summary(m38)
m38.res=c("m38",m38$loglik,summary(m38)$AIC,summary(m38)$BIC)

####混合分布的构成为sstd、sstd、sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd","sstd","sstd")))
m39=FitML(spec,shibor.rt)
summary(m39)
m39.res=c("m39",m39$loglik,summary(m39)$AIC,summary(m39)$BIC)

####混合分布的构成为ged、ged、ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged","ged","ged")))
m40=FitML(spec,shibor.rt)
summary(m40)
m40.res=c("m40",m40$loglik,summary(m40)$AIC,summary(m40)$BIC)

####混合分布的构成为sged、sged、sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged","sged","sged")))
m41=FitML(spec,shibor.rt)
summary(m41)
m41.res=c("m41",m41$loglik,summary(m41)$AIC,summary(m41)$BIC)

##两阶段混合,switch.spec=list(do.mix=T)
###混合形式为sGARCH、sGARCH
####混合分布的构成为norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm")),switch.spec=list(do.mix=T))
m42=FitML(spec,shibor.rt)
summary(m42)
m42.res=c("m42",m42$loglik,summary(m42)$AIC,summary(m42)$BIC)

####混合分布的构成为snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm")),switch.spec=list(do.mix=T))
m43=FitML(spec,shibor.rt)
summary(m43)
m43.res=c("m43",m43$loglik,summary(m43)$AIC,summary(m43)$BIC)

####混合分布的构成为std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std")),switch.spec=list(do.mix=T))
m44=FitML(spec,shibor.rt)
summary(m44)
m44.res=c("m44",m44$loglik,summary(m44)$AIC,summary(m44)$BIC)

####混合分布的构成为sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd")),switch.spec=list(do.mix=T))
m45=FitML(spec,shibor.rt)
summary(m45)
m45.res=c("m45",m45$loglik,summary(m45)$AIC,summary(m45)$BIC)

####混合分布的构成为ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged")),switch.spec=list(do.mix=T))
m46=FitML(spec,shibor.rt)
summary(m46)
m46.res=c("m46",m46$loglik,summary(m46)$AIC,summary(m46)$BIC)

####混合分布的构成为sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged")),switch.spec=list(do.mix=T))
m47=FitML(spec,shibor.rt)
summary(m47)
m47.res=c("m47",m47$loglik,summary(m47)$AIC,summary(m47)$BIC)

##三阶段混合,switch.spec=list(do.mix=T)
###混合形式为sGARCH、sGARCH、sGARCH
####混合分布的构成为norm、norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm","norm")),switch.spec=list(do.mix=T))
m48=FitML(spec,shibor.rt)
summary(m48)
m48.res=c("m48",m48$loglik,summary(m48)$AIC,summary(m48)$BIC)

####混合分布的构成为snorm、snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm","snorm")),switch.spec=list(do.mix=T))
m49=FitML(spec,shibor.rt)
summary(m49)
m49.res=c("m49",m49$loglik,summary(m49)$AIC,summary(m49)$BIC)

####混合分布的构成为std、std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std","std")),switch.spec=list(do.mix=T))
m50=FitML(spec,shibor.rt)
summary(m50)
m50.res=c("m50",m50$loglik,summary(m50)$AIC,summary(m50)$BIC)

####混合分布的构成为sstd、sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd","sstd")),switch.spec=list(do.mix=T))
m51=FitML(spec,shibor.rt)
summary(m51)
m51.res=c("m51",m51$loglik,summary(m51)$AIC,summary(m51)$BIC)

####混合分布的构成为ged、ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged","ged")),switch.spec=list(do.mix=T))
m52=FitML(spec,shibor.rt)
summary(m52)
m52.res=c("m52",m52$loglik,summary(m52)$AIC,summary(m52)$BIC)

####混合分布的构成为sged、sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged","sged")),switch.spec=list(do.mix=T))
m53=FitML(spec,shibor.rt)
summary(m53)
m53.res=c("m53",m53$loglik,summary(m53)$AIC,summary(m53)$BIC)

##四阶段混合,switch.spec=list(do.mix=T)
###混合形式为sGARCH、sGARCH、sGARCH、sGARCH
####混合分布的构成为norm、norm、norm、norm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("norm", "norm","norm","norm")),switch.spec=list(do.mix=T))
m54=FitML(spec,shibor.rt)
summary(m54)
m54.res=c("m54",m54$loglik,summary(m54)$AIC,summary(m54)$BIC)

####混合分布的构成为snorm、snorm、snorm、snorm
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("snorm", "snorm","snorm","snorm")),switch.spec=list(do.mix=T))
m55=FitML(spec,shibor.rt)
summary(m55)
m55.res=c("m55",m55$loglik,summary(m55)$AIC,summary(m55)$BIC)

####混合分布的构成为std、std、std、std
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("std", "std","std","std")),switch.spec=list(do.mix=T))
m56=FitML(spec,shibor.rt)
summary(m56)
m56.res=c("m56",m56$loglik,summary(m56)$AIC,summary(m56)$BIC)

####混合分布的构成为sstd、sstd、sstd、sstd
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sstd", "sstd","sstd","sstd")),switch.spec=list(do.mix=T))
m57=FitML(spec,shibor.rt)
summary(m57)
m57.res=c("m57",m57$loglik,summary(m57)$AIC,summary(m57)$BIC)

####混合分布的构成为ged、ged、ged、ged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("ged", "ged","ged","ged")),switch.spec=list(do.mix=T))
m58=FitML(spec,shibor.rt)
summary(m58)
m58.res=c("m58",m58$loglik,summary(m58)$AIC,summary(m58)$BIC)

####混合分布的构成为sged、sged、sged、sged
spec=CreateSpec(variance.spec = list(model=c("sGARCH","sGARCH","sGARCH","sGARCH")),distribution.spec = list(distribution=c("sged", "sged","sged","sged")),switch.spec=list(do.mix=T))
m59=FitML(spec,shibor.rt)
summary(m59)
m59.res=c("m59",m59$loglik,summary(m59)$AIC,summary(m59)$BIC)

res3=data.frame(m9.res,m10.res,m11.res,m12.res,m13.res,m14.res,m15.res,m16.res,m17.res,m18.res,m19.res,m20.res,m21.res,m22.res,m23.res,m24.res,m25.res,m26.res,m27.res,m28.res,m29.res,m30.res,m31.res,m32.res,m33.res,m34.res,m35.res,m37.res,m38.res,m39.res,m40.res,m41.res,m42.res,m43.res,m44.res,m45.res,m46.res,m47.res,m48.res,m49.res,m50.res,m51.res,m52.res,m53.res,m54.res,m55.res,m56.res,m57.res,m58.res,m59.res)
View(res3)
#以上模型根据AIC和BIC准则，选择41、53

auto.arima(shibor.rt)
library(rugarch)
spec <- ugarchspec(variance.model = list(model = "fGARCH", 
                                         garchOrder = c(1, 1), 
                                         submodel = "TGARCH" ,
                                         external.regressors = NULL, 
                                         variance.targeting = FALSE), 
                   mean.model     = list(armaOrder = c(1, 0), 
                                         external.regressors = NULL),
                   distribution.model = "norm" ,
                   start.pars = list(),
                   fixed.pars = list())

garchm39 <- ugarchfit(spec = spec, data = shibor.rt, solver.control = list(trace=0))
garchm39@model



realdata=read.csv("C:\\Users\\Administrator\\Documents\\WeChat Files\\g18434365732_\\Files\\金\\论文\\回测数据.csv",header=T)
shibor2<-realdata[,2]
shibor.date2<-as.Date(realdata[,1])
par(mfrow=c(1,2)) 
plot(shibor.date2,shibor2,type="l",xlab="日期",ylab="隔夜拆借利率")
n2<-length(shibor2)
shibor.rt2<-log(shibor2[2:n2])-log(shibor2[1:n2-1])
#收益率转为时间序列LOGRt-LOGR(t-1) 
rt2<-ts(shibor.rt2)
plot(rt2,type="l",xlab="日期",ylab="对数收益率",cex.main=0.95,las=1)
risk38<- Risk(m38, alpha = c(0.01, 0.05), nahead = 253)
plot(risk38,xlim=c(0,253))
lines(rt2)

risk27<- Risk(m27, alpha = c(0.01, 0.05), nahead = 253)
mode(risk27)
mode(risk27[[1]])
a=as.matrix(risk27[[1]])
a[,2]


a=as.matrix(risk38[[1]])
a[,2]
k=0
for(i in 1:253){
  if(a[i,2]<rt2[i]){
    k=k+1
  }
}
k
plot(risk27,xlim=c(1,253))
lines(rt2)
predict(m36,nahead=5)
a=State(m27)
State(m27,par,realdata)
par=c(0.0000,0.0485,0.9483,2.6745,0.8013,0.0000,0.9998,0.0000,7.4986,1.0849,0.0037,0.9997,
  0.0000,2.4191,1.8126,0.8654,0.0968,0.1587,0.8201,0.0000,0.2068)

risk20<- Risk(m20, alpha = c(0.01, 0.05), nahead = 253)
plot(risk20,xlim=c(0,253))
lines(rt2)
a=as.matrix(risk20[[1]])
a[,2]
k=0
for(i in 1:253){
  if(a[i,2]<rt2[i]){
    k=k+1
  }
}
k
```

# 结论

# 参考文献
[//]: # (\bibliography{msgarch})
